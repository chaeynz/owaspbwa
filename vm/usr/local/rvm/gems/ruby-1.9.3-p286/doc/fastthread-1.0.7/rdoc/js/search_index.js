var search_data = {"index":{"searchIndex":["conditionvariable","mutex","queue","sizedqueue","broadcast()","clear()","clear()","empty?()","empty?()","exclusive_unlock()","length()","length()","lock()","locked?()","marshal_dump()","marshal_dump()","marshal_dump()","marshal_load()","marshal_load()","marshal_load()","max()","max=()","new()","num_waiting()","num_waiting()","pop()","pop()","push()","push()","signal()","synchronize()","try_lock()","unlock()","wait()","changelog","makefile"],"longSearchIndex":["conditionvariable","mutex","queue","sizedqueue","conditionvariable#broadcast()","queue#clear()","sizedqueue#clear()","queue#empty?()","sizedqueue#empty?()","mutex#exclusive_unlock()","queue#length()","sizedqueue#length()","mutex#lock()","mutex#locked?()","conditionvariable#marshal_dump()","mutex#marshal_dump()","queue#marshal_dump()","conditionvariable#marshal_load()","mutex#marshal_load()","queue#marshal_load()","sizedqueue#max()","sizedqueue#max=()","sizedqueue::new()","queue#num_waiting()","sizedqueue#num_waiting()","queue#pop()","sizedqueue#pop()","queue#push()","sizedqueue#push()","conditionvariable#signal()","mutex#synchronize()","mutex#try_lock()","mutex#unlock()","conditionvariable#wait()","",""],"info":[["ConditionVariable","","ConditionVariable.html","","<p>ConditionVariable objects augment class Mutex. Using condition variables,\nit is possible to suspend while ...\n"],["Mutex","","Mutex.html","","<p>Mutex implements a simple semaphore that can be used to coordinate access\nto shared data from multiple ...\n"],["Queue","","Queue.html","","<p>This class provides a way to synchronize communication between threads.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'thread'</span>\n\n<span class=\"ruby-identifier\">queue</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["SizedQueue","","SizedQueue.html","","<p>This class represents queues of specified size capacity.  The push\noperation may be blocked if the capacity ...\n"],["broadcast","ConditionVariable","ConditionVariable.html#method-i-broadcast","()","<p>Wakes up all threads waiting for this condition.\n"],["clear","Queue","Queue.html#method-i-clear","()","<p>Removes all objects from the queue.\n"],["clear","SizedQueue","SizedQueue.html#method-i-clear","()","<p>Removes all objects from the queue.\n"],["empty?","Queue","Queue.html#method-i-empty-3F","()","<p>Returns <code>true</code> if the queue is empty.\n"],["empty?","SizedQueue","SizedQueue.html#method-i-empty-3F","()","<p>Returns <code>true</code> if the queue is empty.\n"],["exclusive_unlock","Mutex","Mutex.html#method-i-exclusive_unlock","()","<p>If the mutex is locked, unlocks the mutex, wakes one waiting thread, and\nyields in a critical section. ...\n"],["length","Queue","Queue.html#method-i-length","()","<p>Returns the length of the queue.\n"],["length","SizedQueue","SizedQueue.html#method-i-length","()","<p>Returns the length of the queue.\n"],["lock","Mutex","Mutex.html#method-i-lock","()","<p>Attempts to grab the lock and waits if it isn't available.\n"],["locked?","Mutex","Mutex.html#method-i-locked-3F","()","<p>Returns <code>true</code> if this lock is currently held by some thread.\n"],["marshal_dump","ConditionVariable","ConditionVariable.html#method-i-marshal_dump","()",""],["marshal_dump","Mutex","Mutex.html#method-i-marshal_dump","()",""],["marshal_dump","Queue","Queue.html#method-i-marshal_dump","()",""],["marshal_load","ConditionVariable","ConditionVariable.html#method-i-marshal_load","(p1)","<p>for marshalling mutexes and condvars\n"],["marshal_load","Mutex","Mutex.html#method-i-marshal_load","(p1)","<p>for marshalling mutexes and condvars\n"],["marshal_load","Queue","Queue.html#method-i-marshal_load","(p1)",""],["max","SizedQueue","SizedQueue.html#method-i-max","()","<p>Returns the maximum size of the queue.\n"],["max=","SizedQueue","SizedQueue.html#method-i-max-3D","(p1)","<p>Sets the maximum size of the queue.\n"],["new","SizedQueue","SizedQueue.html#method-c-new","(p1)","<p>Creates a new Mutex\n"],["num_waiting","Queue","Queue.html#method-i-num_waiting","()","<p>Returns the number of threads waiting on the queue.\n"],["num_waiting","SizedQueue","SizedQueue.html#method-i-num_waiting","()","<p>Returns the number of threads waiting on the queue.\n"],["pop","Queue","Queue.html#method-i-pop","(*args)","\n<pre>call_seq: pop(non_block=false)</pre>\n<p>Retrieves data from the queue.  If the queue is empty, the calling thread\n...\n"],["pop","SizedQueue","SizedQueue.html#method-i-pop","(*args)","\n<pre>call_seq: pop(non_block=false)</pre>\n<p>Retrieves data from the queue.  If the queue is empty, the calling thread\n...\n"],["push","Queue","Queue.html#method-i-push","(p1)","<p>Pushes <code>obj</code> to the queue.\n"],["push","SizedQueue","SizedQueue.html#method-i-push","(p1)","<p>Pushes <code>obj</code> to the queue.\n"],["signal","ConditionVariable","ConditionVariable.html#method-i-signal","()","<p>Wakes up the first thread in line waiting for this condition.\n"],["synchronize","Mutex","Mutex.html#method-i-synchronize","()","<p>Obtains a lock, runs the block, and releases the lock when the block\ncompletes.  See the example under ...\n"],["try_lock","Mutex","Mutex.html#method-i-try_lock","()","<p>Attempts to obtain the lock and returns immediately. Returns\n<code>true</code> if the lock was granted.\n"],["unlock","Mutex","Mutex.html#method-i-unlock","()","<p>Releases the lock. Returns <code>nil</code> if ref wasn't locked.\n"],["wait","ConditionVariable","ConditionVariable.html#method-i-wait","(p1)","<p>Releases the lock held in <code>mutex</code> and waits; reacquires the lock\non wakeup.\n"],["CHANGELOG","","CHANGELOG.html","","<p>v1.0.7  Enable for all 1.8.x versions; add fix for 1.8.6 patchlevels &lt;\n31\n<p>v1.0.6  Try again for 1.8.5. …\n"],["Makefile","","ext/fastthread/Makefile.html","","<p>DESTDIR =  MAJOR = 1 MINOR = 9 TEENY = 1 PATCHLEVEL = 286 INSTALL =\n/usr/bin/install -c EXEEXT =  prefix …\n"]]}}