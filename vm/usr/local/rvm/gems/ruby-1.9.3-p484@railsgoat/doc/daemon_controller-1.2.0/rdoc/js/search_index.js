var search_data = {"index":{"searchIndex":["daemoncontroller","alreadystarted","connecterror","daemonizationtimeout","error","lockfile","alreadylocked","starterror","starttimeout","stoperror","stoptimeout","timeouterror","object","can_ping_unix_sockets?()","connect()","exclusive_lock()","new()","new()","pid()","restart()","running?()","shared_lock()","start()","stop()","try_exclusive_lock()","try_shared_lock()"],"longSearchIndex":["daemoncontroller","daemoncontroller::alreadystarted","daemoncontroller::connecterror","daemoncontroller::daemonizationtimeout","daemoncontroller::error","daemoncontroller::lockfile","daemoncontroller::lockfile::alreadylocked","daemoncontroller::starterror","daemoncontroller::starttimeout","daemoncontroller::stoperror","daemoncontroller::stoptimeout","daemoncontroller::timeouterror","object","daemoncontroller::can_ping_unix_sockets?()","daemoncontroller#connect()","daemoncontroller::lockfile#exclusive_lock()","daemoncontroller::new()","daemoncontroller::lockfile::new()","daemoncontroller#pid()","daemoncontroller#restart()","daemoncontroller#running?()","daemoncontroller::lockfile#shared_lock()","daemoncontroller#start()","daemoncontroller#stop()","daemoncontroller::lockfile#try_exclusive_lock()","daemoncontroller::lockfile#try_shared_lock()"],"info":[["DaemonController","","DaemonController.html","","<p>Main daemon controller object. See the README for an introduction and\ntutorial.\n<p>daemon_controller, library …\n"],["DaemonController::AlreadyStarted","","DaemonController/AlreadyStarted.html","",""],["DaemonController::ConnectError","","DaemonController/ConnectError.html","",""],["DaemonController::DaemonizationTimeout","","DaemonController/DaemonizationTimeout.html","",""],["DaemonController::Error","","DaemonController/Error.html","",""],["DaemonController::LockFile","","DaemonController/LockFile.html","","<p>A lock file is a synchronization mechanism, like a Mutex, but it also\nallows inter-process synchronization …\n"],["DaemonController::LockFile::AlreadyLocked","","DaemonController/LockFile/AlreadyLocked.html","",""],["DaemonController::StartError","","DaemonController/StartError.html","",""],["DaemonController::StartTimeout","","DaemonController/StartTimeout.html","",""],["DaemonController::StopError","","DaemonController/StopError.html","",""],["DaemonController::StopTimeout","","DaemonController/StopTimeout.html","",""],["DaemonController::TimeoutError","","DaemonController/TimeoutError.html","",""],["Object","","Object.html","",""],["can_ping_unix_sockets?","DaemonController","DaemonController.html#method-c-can_ping_unix_sockets-3F","()","<p>Checks whether ping Unix domain sockets is supported. Currently this is\nsupported on all Ruby implementations, …\n"],["connect","DaemonController","DaemonController.html#method-i-connect","()","<p>Connect to the daemon by running the given block, which contains the\nconnection logic. If the daemon …\n"],["exclusive_lock","DaemonController::LockFile","DaemonController/LockFile.html#method-i-exclusive_lock","()","<p>Obtain an exclusive lock on the lock file, yield the given block, then\nunlock the lockfile. If the lock …\n"],["new","DaemonController","DaemonController.html#method-c-new","(options)","<p>Create a new DaemonController object.\n<p>Mandatory options\n<p>:identifier &mdash; A human-readable, unique name for this …\n"],["new","DaemonController::LockFile","DaemonController/LockFile.html#method-c-new","(filename)","<p>Create a LockFile object. The lock file is initially not locked.\n<p><code>filename</code> may point to a nonexistant file. ...\n"],["pid","DaemonController","DaemonController.html#method-i-pid","()","<p>Returns the daemon’s PID, as reported by its PID file. Returns the PID as\nan integer, or nil there is …\n"],["restart","DaemonController","DaemonController.html#method-i-restart","()","<p>Restarts the daemon. Uses the restart_command if provided, otherwise calls\n#stop and #start.\n"],["running?","DaemonController","DaemonController.html#method-i-running-3F","()","<p>Checks whether the daemon is still running. This is done by reading the PID\nfile and then checking whether …\n"],["shared_lock","DaemonController::LockFile","DaemonController/LockFile.html#method-i-shared_lock","()","<p>Obtain an exclusive lock on the lock file, yield the given block, then\nunlock the lockfile. If the lock …\n"],["start","DaemonController","DaemonController.html#method-i-start","()","<p>Start the daemon and wait until it can be pinged.\n<p>Raises:\n<p>AlreadyStarted - the daemon is already running. …\n"],["stop","DaemonController","DaemonController.html#method-i-stop","()","<p>Stop the daemon and wait until it has exited.\n<p>Raises:\n<p>StopError - the stop command failed.\n"],["try_exclusive_lock","DaemonController::LockFile","DaemonController/LockFile.html#method-i-try_exclusive_lock","()","<p>Try to obtain an exclusive lock on the lock file, similar to\n#exclusive_lock. But unlike #exclusive_lock …\n"],["try_shared_lock","DaemonController::LockFile","DaemonController/LockFile.html#method-i-try_shared_lock","()","<p>Try to obtain a shared lock on the lock file, similar to #shared_lock. But\nunlike #shared_lock, this …\n"]]}}