<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Apache Portable Runtime: Threads and Process Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Threads and Process Functions<br/>
<small>
[<a class="el" href="group___a_p_r.html">Apache Portability Runtime library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__proc__t.html">apr_proc_t</a></td></tr>
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___o_c.html">Other Child Flags</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga689b0f3953cde83a4092931bad8b7183">APR_PROC_CHECK_EXIT</a>(x)&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_EXIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaa0a8a0b8785cc9392059c7accd71f5f6">APR_PROC_CHECK_SIGNALED</a>(x)&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_SIGNAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga2249e96191b5d98d33fb7875bce49410">APR_PROC_CHECK_CORE_DUMP</a>(x)&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_SIGNAL_CORE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gab7cfcb8ed24e6c0a76cd41b5b113ae95">APR_NO_PIPE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga646af57314e71f4647243f36dd03e5ea">APR_FULL_BLOCK</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gae0707f76da785490830fc3491093767c">APR_FULL_NONBLOCK</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga8653bab028b1c2b98754babc2547f988">APR_PARENT_BLOCK</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gacad9da4db7a22f46715e50fb8ec1c939">APR_CHILD_BLOCK</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga597fb6a501c20cc3a597fe6c613f4310">APR_NO_FILE</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga597fb6a501c20cc3a597fe6c613f4310">APR_NO_FILE</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaf8295548cb0821ee02249d6de8336bcb">APR_READ_BLOCK</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga36ff2de9664ad6995bd488b4ac715c9c">APR_WRITE_BLOCK</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaad8a94c7ac2be58fe035b2fd6efec84f">APR_LIMIT_CPU</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga6dbb01bb357b078acff8fd87e9c494e8">APR_LIMIT_MEM</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga72e9be453a20f4e78bc6d7bd95d7c333">APR_LIMIT_NPROC</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga18d73099d66988698a9ad2aebdce2c9f">APR_LIMIT_NOFILE</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gab57b448a464ac299c03d6127781df152">APR_PROC_DETACH_FOREGROUND</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gab4de7134fcc66c4127ae65b68631f846">APR_PROC_DETACH_DAEMONIZE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga8f8642f468f05b0ac2b1426b723af100">apr_child_errfn_t</a> )(<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *proc, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> err, const char *description)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *(APR_THREAD_FUNC *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga37193850d158ca870fc8f8759f0725a9">apr_thread_start_t</a> )(<a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *, void *)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gadcb981d7748c580eb69ac11dbf709060">apr_cmdtype_e</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__apr__thread__proc.html#ggadcb981d7748c580eb69ac11dbf709060a02f5d83f79e2c12bfca5a86d7f14caa6">APR_SHELLCMD</a>, 
<a class="el" href="group__apr__thread__proc.html#ggadcb981d7748c580eb69ac11dbf709060ac128c1239a524cf21300b8ed6248ac99">APR_PROGRAM</a>, 
<a class="el" href="group__apr__thread__proc.html#ggadcb981d7748c580eb69ac11dbf709060a6a3f9694aced0e449f6bb4b3e437233a">APR_PROGRAM_ENV</a>, 
<a class="el" href="group__apr__thread__proc.html#ggadcb981d7748c580eb69ac11dbf709060aa424b51bdc16e4d18bb757a32c6a346a">APR_PROGRAM_PATH</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__apr__thread__proc.html#ggadcb981d7748c580eb69ac11dbf709060afcefc45317b67fad6dc5459772ce9409">APR_SHELLCMD_ENV</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a> { <a class="el" href="group__apr__thread__proc.html#gga5e52d786644f3b66d6180571e68c7260a057885ccf4b8b707e0d115c691037de4">APR_WAIT</a>, 
<a class="el" href="group__apr__thread__proc.html#gga5e52d786644f3b66d6180571e68c7260a0163031f6b72b0c4add9108052a672d5">APR_NOWAIT</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a> { <a class="el" href="group__apr__thread__proc.html#ggac097b4fa41e67024711c5983446d0951a977f140c82333af62aa4bed8c99a3ee2">APR_PROC_EXIT</a> =  1, 
<a class="el" href="group__apr__thread__proc.html#ggac097b4fa41e67024711c5983446d0951a7e3421d18abe458ca27822d19424225b">APR_PROC_SIGNAL</a> =  2, 
<a class="el" href="group__apr__thread__proc.html#ggac097b4fa41e67024711c5983446d0951a6b667be4983cb59e9bed37ee05a0dcce">APR_PROC_SIGNAL_CORE</a> =  4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga3eaec78633742e7e0cb9480a21477aff">apr_kill_conditions_e</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__apr__thread__proc.html#gga3eaec78633742e7e0cb9480a21477affa33580ab0809e9498855fbdde8a1714ef">APR_KILL_NEVER</a>, 
<a class="el" href="group__apr__thread__proc.html#gga3eaec78633742e7e0cb9480a21477affaf45d0f72811399b394d1311384e2dfe4">APR_KILL_ALWAYS</a>, 
<a class="el" href="group__apr__thread__proc.html#gga3eaec78633742e7e0cb9480a21477affa16a47aa786b1c1f31ef02353bcae9a1a">APR_KILL_AFTER_TIMEOUT</a>, 
<a class="el" href="group__apr__thread__proc.html#gga3eaec78633742e7e0cb9480a21477affa6ada2605856ac94826edbe824e64e503">APR_JUST_WAIT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__apr__thread__proc.html#gga3eaec78633742e7e0cb9480a21477affa24d6f47785093be4cea2a922eeaed098">APR_KILL_ONLY_ONCE</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga66c2f55e5dff9ac37bd32e9febd38da5">apr_threadattr_create</a> (<a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> **new_attr, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga85d44b3b021f28116122d5e40e024648">apr_threadattr_detach_set</a> (<a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *attr, apr_int32_t on)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gae5b7cdb3de542d1b7b52fe5d9d8cb00b">apr_threadattr_detach_get</a> (<a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *attr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga7849e0d637338a18cb44f66f11f28ed1">apr_threadattr_stacksize_set</a> (<a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *attr, apr_size_t stacksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga2e732f2913291180c0c484f57d727140">apr_threadattr_guardsize_set</a> (<a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *attr, apr_size_t guardsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaeba6593f43f1de94c2b4495dd72b0e9f">apr_thread_create</a> (<a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> **new_thread, <a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *attr, <a class="el" href="group__apr__thread__proc.html#ga37193850d158ca870fc8f8759f0725a9">apr_thread_start_t</a> func, void *data, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga0e35365e530578bca1b4bea522ac8c85">apr_thread_exit</a> (<a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thd, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> retval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga1b950f36fa5bcd5a64887073f46f6d13">apr_thread_join</a> (<a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> *retval, <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gacd69fb862c069cb6f297f65d64b5c102">apr_thread_yield</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga63f3bf667151053e45d5a2029daeda0d">apr_thread_once_init</a> (<a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a> **control, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga8f3645ee52ff07566c92181b4ce732d8">apr_thread_once</a> (<a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a> *control, void(*func)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gadbd186912d5f6f2a19a175e1e02ba10e">apr_thread_detach</a> (<a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gad799c8140ed068a12f1dbe134423eae7">apr_thread_data_get</a> (void **data, const char *key, <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaa90d79c9935692db4f27a6573f437221">apr_thread_data_set</a> (void *data, const char *key, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*cleanup)(void *), <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gacb9553b2b3165388bfc0a54b1148804a">apr_threadkey_private_create</a> (<a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> **key, void(*dest)(void *), <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga371c87c122cc3df0b7ad0031f6e11167">apr_threadkey_private_get</a> (void **new_mem, <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga63501a064ca7f1818aa056b40146aa0b">apr_threadkey_private_set</a> (void *priv, <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga20b9b79892a6532784fff023a4ebd8cf">apr_threadkey_private_delete</a> (<a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gae203664972dfc5c555620ae1788f5b48">apr_threadkey_data_get</a> (void **data, const char *key, <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *threadkey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga1059158f34dded87f21ba82af1211951">apr_threadkey_data_set</a> (void *data, const char *key, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*cleanup)(void *), <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *threadkey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga90f8ef684e601c110daad9b63da53cf3">apr_procattr_create</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> **new_attr, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *cont)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, apr_int32_t in, apr_int32_t out, apr_int32_t err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga24f40119b1aa07dd45a681a44915cb1b">apr_procattr_child_in_set</a> (struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *child_in, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *parent_in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gabb97e9a49021ab4452ae3f1a281c977f">apr_procattr_child_out_set</a> (struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *child_out, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *parent_out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga6fad364c6c820e37c0915435cfb3921f">apr_procattr_child_err_set</a> (struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *child_err, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *parent_err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga97766f50b0ae083a2f8a28e698a59baa">apr_procattr_dir_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, const char *dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga1426acc5bdd96385769e7b42bfa6ebbd">apr_procattr_cmdtype_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__thread__proc.html#gadcb981d7748c580eb69ac11dbf709060">apr_cmdtype_e</a> cmd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga3ccca55041f648f00f0605673d4e0fdc">apr_procattr_detach_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, apr_int32_t detach)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaa39deba0837e0772754ad41589b733cf">apr_procattr_child_errfn_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__thread__proc.html#ga8f8642f468f05b0ac2b1426b723af100">apr_child_errfn_t</a> *errfn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga24076f050e9385af09ad8c3931d8dc43">apr_procattr_error_check_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, apr_int32_t chk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga0f1dd02408995767efcb9c0d9c775620">apr_procattr_addrspace_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, apr_int32_t addrspace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga741ed3dc047b935b091a21528c49bb19">apr_procattr_user_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, const char *username, const char *password)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga391f0d3831a5894ea2118762789a395d">apr_procattr_group_set</a> (<a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, const char *groupname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *new_proc, const char *progname, const char *const *args, const char *const *env, <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *attr, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga0936f7a7fe7e2d5e08979c9f343a5a1b">apr_proc_wait</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, int *exitcode, <a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a> *exitwhy, <a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a> waithow)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga506183074e8413c3ff597539e4768ea4">apr_proc_wait_all_procs</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, int *exitcode, <a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a> *exitwhy, <a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a> waithow, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga56c2b005792752b63d804f2021596406">apr_proc_detach</a> (int daemonize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gaf8d2be452a819161aa4cd6205a17761e">apr_proc_other_child_register</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, void(*maintenance)(int reason, void *, int status), void *data, <a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *write_fd, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga10b1a4b224566c03c97f100ac8a2c830">apr_proc_other_child_unregister</a> (void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga88701979c4e5ac4b94966c73e0159efd">apr_proc_other_child_alert</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, int reason, int status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga74a905d90a3476a611adeeb304931a6c">apr_proc_other_child_refresh</a> (<a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a> *ocr, int reason)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gacff5e867a92619d30c4e78f9ad2a58e3">apr_proc_other_child_refresh_all</a> (int reason)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga4a5ff2fce2c68460281b0cb3ee0365d5">apr_proc_kill</a> (<a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, int sig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#gacbe3fd9491fa35149de28cebcae22f87">apr_pool_note_subprocess</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *a, <a class="el" href="structapr__proc__t.html">apr_proc_t</a> *proc, <a class="el" href="group__apr__thread__proc.html#ga3eaec78633742e7e0cb9480a21477aff">apr_kill_conditions_e</a> how)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__thread__proc.html#ga089b70ae9d6c64d2675a1fd1e9cd0d0d">apr_thread_pool_get</a> (const <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *thethread)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gacad9da4db7a22f46715e50fb8ec1c939"></a><!-- doxytag: member="apr_thread_proc.h::APR_CHILD_BLOCK" ref="gacad9da4db7a22f46715e50fb8ec1c939" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_CHILD_BLOCK&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga646af57314e71f4647243f36dd03e5ea"></a><!-- doxytag: member="apr_thread_proc.h::APR_FULL_BLOCK" ref="ga646af57314e71f4647243f36dd03e5ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_FULL_BLOCK&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> and <a class="el" href="group__apr__file__io.html#gac365ab74c583eb1df5cd05660a81b5c8">apr_file_pipe_create_ex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae0707f76da785490830fc3491093767c"></a><!-- doxytag: member="apr_thread_proc.h::APR_FULL_NONBLOCK" ref="gae0707f76da785490830fc3491093767c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_FULL_NONBLOCK&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> and <a class="el" href="group__apr__file__io.html#gac365ab74c583eb1df5cd05660a81b5c8">apr_file_pipe_create_ex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad8a94c7ac2be58fe035b2fd6efec84f"></a><!-- doxytag: member="apr_thread_proc.h::APR_LIMIT_CPU" ref="gaad8a94c7ac2be58fe035b2fd6efec84f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_LIMIT_CPU&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd>apr_procattr_limit_set </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dbb01bb357b078acff8fd87e9c494e8"></a><!-- doxytag: member="apr_thread_proc.h::APR_LIMIT_MEM" ref="ga6dbb01bb357b078acff8fd87e9c494e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_LIMIT_MEM&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd>apr_procattr_limit_set </dd></dl>

</div>
</div>
<a class="anchor" id="ga18d73099d66988698a9ad2aebdce2c9f"></a><!-- doxytag: member="apr_thread_proc.h::APR_LIMIT_NOFILE" ref="ga18d73099d66988698a9ad2aebdce2c9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_LIMIT_NOFILE&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd>apr_procattr_limit_set </dd></dl>

</div>
</div>
<a class="anchor" id="ga72e9be453a20f4e78bc6d7bd95d7c333"></a><!-- doxytag: member="apr_thread_proc.h::APR_LIMIT_NPROC" ref="ga72e9be453a20f4e78bc6d7bd95d7c333" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_LIMIT_NPROC&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd>apr_procattr_limit_set </dd></dl>

</div>
</div>
<a class="anchor" id="ga597fb6a501c20cc3a597fe6c613f4310"></a><!-- doxytag: member="apr_thread_proc.h::APR_NO_FILE" ref="ga597fb6a501c20cc3a597fe6c613f4310" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_NO_FILE&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a></dd>
<dd>
<a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Win32 only effective with version 1.2.12, portably introduced in 1.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga597fb6a501c20cc3a597fe6c613f4310"></a><!-- doxytag: member="apr_thread_proc.h::APR_NO_FILE" ref="ga597fb6a501c20cc3a597fe6c613f4310" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_NO_FILE&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a></dd>
<dd>
<a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Win32 only effective with version 1.2.12, portably introduced in 1.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gab7cfcb8ed24e6c0a76cd41b5b113ae95"></a><!-- doxytag: member="apr_thread_proc.h::APR_NO_PIPE" ref="gab7cfcb8ed24e6c0a76cd41b5b113ae95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_NO_PIPE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8653bab028b1c2b98754babc2547f988"></a><!-- doxytag: member="apr_thread_proc.h::APR_PARENT_BLOCK" ref="ga8653bab028b1c2b98754babc2547f988" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PARENT_BLOCK&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2249e96191b5d98d33fb7875bce49410"></a><!-- doxytag: member="apr_thread_proc.h::APR_PROC_CHECK_CORE_DUMP" ref="ga2249e96191b5d98d33fb7875bce49410" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PROC_CHECK_CORE_DUMP</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_SIGNAL_CORE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>did we get core </p>

</div>
</div>
<a class="anchor" id="ga689b0f3953cde83a4092931bad8b7183"></a><!-- doxytag: member="apr_thread_proc.h::APR_PROC_CHECK_EXIT" ref="ga689b0f3953cde83a4092931bad8b7183" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PROC_CHECK_EXIT</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_EXIT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>did we exit the process </p>

</div>
</div>
<a class="anchor" id="gaa0a8a0b8785cc9392059c7accd71f5f6"></a><!-- doxytag: member="apr_thread_proc.h::APR_PROC_CHECK_SIGNALED" ref="gaa0a8a0b8785cc9392059c7accd71f5f6" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PROC_CHECK_SIGNALED</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(x &amp; APR_PROC_SIGNAL)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>did we get a signal </p>

</div>
</div>
<a class="anchor" id="gab4de7134fcc66c4127ae65b68631f846"></a><!-- doxytag: member="apr_thread_proc.h::APR_PROC_DETACH_DAEMONIZE" ref="gab4de7134fcc66c4127ae65b68631f846" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PROC_DETACH_DAEMONIZE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detach </p>

</div>
</div>
<a class="anchor" id="gab57b448a464ac299c03d6127781df152"></a><!-- doxytag: member="apr_thread_proc.h::APR_PROC_DETACH_FOREGROUND" ref="gab57b448a464ac299c03d6127781df152" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_PROC_DETACH_FOREGROUND&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do not detach </p>

</div>
</div>
<a class="anchor" id="gaf8295548cb0821ee02249d6de8336bcb"></a><!-- doxytag: member="apr_thread_proc.h::APR_READ_BLOCK" ref="gaf8295548cb0821ee02249d6de8336bcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_READ_BLOCK&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__file__io.html#gac365ab74c583eb1df5cd05660a81b5c8">apr_file_pipe_create_ex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga36ff2de9664ad6995bd488b4ac715c9c"></a><!-- doxytag: member="apr_thread_proc.h::APR_WRITE_BLOCK" ref="ga36ff2de9664ad6995bd488b4ac715c9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_WRITE_BLOCK&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__file__io.html#gac365ab74c583eb1df5cd05660a81b5c8">apr_file_pipe_create_ex</a> </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8f8642f468f05b0ac2b1426b723af100"></a><!-- doxytag: member="apr_thread_proc.h::apr_child_errfn_t" ref="ga8f8642f468f05b0ac2b1426b723af100" args=")(apr_pool_t *proc, apr_status_t err, const char *description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( <a class="el" href="group__apr__thread__proc.html#ga8f8642f468f05b0ac2b1426b723af100">apr_child_errfn_t</a>)(<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *proc, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> err, const char *description)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The prototype for APR child errfn functions. (See the description of <a class="el" href="group__apr__thread__proc.html#gaa39deba0837e0772754ad41589b733cf">apr_procattr_child_errfn_set()</a> for more information.) It is passed the following parameters: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>Pool associated with the <a class="el" href="structapr__proc__t.html">apr_proc_t</a>. If your child error function needs user data, associate it with this pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>APR error code describing the error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>description</em>&nbsp;</td><td>Text description of type of processing which failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc52ee8b19a7b222278d31ebb3f11a71"></a><!-- doxytag: member="apr_thread_proc.h::apr_other_child_rec_t" ref="gafc52ee8b19a7b222278d31ebb3f11a71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a> <a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque record of child process. </p>

</div>
</div>
<a class="anchor" id="ga0d83919a6a0dd609598a864917f8b339"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_t" ref="ga0d83919a6a0dd609598a864917f8b339" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque Process attributes structure. </p>

</div>
</div>
<a class="anchor" id="ga91841bcf20d0579e8e6acc6d3c220ac1"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_once_t" ref="ga91841bcf20d0579e8e6acc6d3c220ac1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a> <a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque control variable for one-time atomic variables. </p>

</div>
</div>
<a class="anchor" id="ga37193850d158ca870fc8f8759f0725a9"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_start_t" ref="ga37193850d158ca870fc8f8759f0725a9" args=")(apr_thread_t *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(APR_THREAD_FUNC * <a class="el" href="group__apr__thread__proc.html#ga37193850d158ca870fc8f8759f0725a9">apr_thread_start_t</a>)(<a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The prototype for any APR thread worker functions. </p>

</div>
</div>
<a class="anchor" id="ga646c71351e723d84f8cc8c8d1d5937be"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_t" ref="ga646c71351e723d84f8cc8c8d1d5937be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque Thread structure. </p>

</div>
</div>
<a class="anchor" id="ga35de571e9944871c10b38d8feef885ac"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_t" ref="ga35de571e9944871c10b38d8feef885ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> <a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque Thread attributes structure. </p>

</div>
</div>
<a class="anchor" id="ga337c9c1bd2d47740022071a5c41f2edb"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_t" ref="ga337c9c1bd2d47740022071a5c41f2edb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> <a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opaque thread private address space. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gadcb981d7748c580eb69ac11dbf709060"></a><!-- doxytag: member="apr_thread_proc.h::apr_cmdtype_e" ref="gadcb981d7748c580eb69ac11dbf709060" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__apr__thread__proc.html#gadcb981d7748c580eb69ac11dbf709060">apr_cmdtype_e</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggadcb981d7748c580eb69ac11dbf709060a02f5d83f79e2c12bfca5a86d7f14caa6"></a><!-- doxytag: member="APR_SHELLCMD" ref="ggadcb981d7748c580eb69ac11dbf709060a02f5d83f79e2c12bfca5a86d7f14caa6" args="" -->APR_SHELLCMD</em>&nbsp;</td><td>
<p>use the shell to invoke the program </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadcb981d7748c580eb69ac11dbf709060ac128c1239a524cf21300b8ed6248ac99"></a><!-- doxytag: member="APR_PROGRAM" ref="ggadcb981d7748c580eb69ac11dbf709060ac128c1239a524cf21300b8ed6248ac99" args="" -->APR_PROGRAM</em>&nbsp;</td><td>
<p>invoke the program directly, no copied env </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadcb981d7748c580eb69ac11dbf709060a6a3f9694aced0e449f6bb4b3e437233a"></a><!-- doxytag: member="APR_PROGRAM_ENV" ref="ggadcb981d7748c580eb69ac11dbf709060a6a3f9694aced0e449f6bb4b3e437233a" args="" -->APR_PROGRAM_ENV</em>&nbsp;</td><td>
<p>invoke the program, replicating our environment </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadcb981d7748c580eb69ac11dbf709060aa424b51bdc16e4d18bb757a32c6a346a"></a><!-- doxytag: member="APR_PROGRAM_PATH" ref="ggadcb981d7748c580eb69ac11dbf709060aa424b51bdc16e4d18bb757a32c6a346a" args="" -->APR_PROGRAM_PATH</em>&nbsp;</td><td>
<p>find program on PATH, use our environment </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggadcb981d7748c580eb69ac11dbf709060afcefc45317b67fad6dc5459772ce9409"></a><!-- doxytag: member="APR_SHELLCMD_ENV" ref="ggadcb981d7748c580eb69ac11dbf709060afcefc45317b67fad6dc5459772ce9409" args="" -->APR_SHELLCMD_ENV</em>&nbsp;</td><td>
<p>use the shell to invoke the program, replicating our environment </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gac097b4fa41e67024711c5983446d0951"></a><!-- doxytag: member="apr_thread_proc.h::apr_exit_why_e" ref="gac097b4fa41e67024711c5983446d0951" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac097b4fa41e67024711c5983446d0951a977f140c82333af62aa4bed8c99a3ee2"></a><!-- doxytag: member="APR_PROC_EXIT" ref="ggac097b4fa41e67024711c5983446d0951a977f140c82333af62aa4bed8c99a3ee2" args="" -->APR_PROC_EXIT</em>&nbsp;</td><td>
<p>process exited normally </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac097b4fa41e67024711c5983446d0951a7e3421d18abe458ca27822d19424225b"></a><!-- doxytag: member="APR_PROC_SIGNAL" ref="ggac097b4fa41e67024711c5983446d0951a7e3421d18abe458ca27822d19424225b" args="" -->APR_PROC_SIGNAL</em>&nbsp;</td><td>
<p>process exited due to a signal </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac097b4fa41e67024711c5983446d0951a6b667be4983cb59e9bed37ee05a0dcce"></a><!-- doxytag: member="APR_PROC_SIGNAL_CORE" ref="ggac097b4fa41e67024711c5983446d0951a6b667be4983cb59e9bed37ee05a0dcce" args="" -->APR_PROC_SIGNAL_CORE</em>&nbsp;</td><td>
<p>process exited and dumped a core file </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3eaec78633742e7e0cb9480a21477aff"></a><!-- doxytag: member="apr_thread_proc.h::apr_kill_conditions_e" ref="ga3eaec78633742e7e0cb9480a21477aff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__apr__thread__proc.html#ga3eaec78633742e7e0cb9480a21477aff">apr_kill_conditions_e</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga3eaec78633742e7e0cb9480a21477affa33580ab0809e9498855fbdde8a1714ef"></a><!-- doxytag: member="APR_KILL_NEVER" ref="gga3eaec78633742e7e0cb9480a21477affa33580ab0809e9498855fbdde8a1714ef" args="" -->APR_KILL_NEVER</em>&nbsp;</td><td>
<p>process is never sent any signals </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3eaec78633742e7e0cb9480a21477affaf45d0f72811399b394d1311384e2dfe4"></a><!-- doxytag: member="APR_KILL_ALWAYS" ref="gga3eaec78633742e7e0cb9480a21477affaf45d0f72811399b394d1311384e2dfe4" args="" -->APR_KILL_ALWAYS</em>&nbsp;</td><td>
<p>process is sent SIGKILL on apr_pool_t cleanup </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3eaec78633742e7e0cb9480a21477affa16a47aa786b1c1f31ef02353bcae9a1a"></a><!-- doxytag: member="APR_KILL_AFTER_TIMEOUT" ref="gga3eaec78633742e7e0cb9480a21477affa16a47aa786b1c1f31ef02353bcae9a1a" args="" -->APR_KILL_AFTER_TIMEOUT</em>&nbsp;</td><td>
<p>SIGTERM, wait 3 seconds, SIGKILL </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3eaec78633742e7e0cb9480a21477affa6ada2605856ac94826edbe824e64e503"></a><!-- doxytag: member="APR_JUST_WAIT" ref="gga3eaec78633742e7e0cb9480a21477affa6ada2605856ac94826edbe824e64e503" args="" -->APR_JUST_WAIT</em>&nbsp;</td><td>
<p>wait forever for the process to complete </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga3eaec78633742e7e0cb9480a21477affa24d6f47785093be4cea2a922eeaed098"></a><!-- doxytag: member="APR_KILL_ONLY_ONCE" ref="gga3eaec78633742e7e0cb9480a21477affa24d6f47785093be4cea2a922eeaed098" args="" -->APR_KILL_ONLY_ONCE</em>&nbsp;</td><td>
<p>send SIGTERM and then wait </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e52d786644f3b66d6180571e68c7260"></a><!-- doxytag: member="apr_thread_proc.h::apr_wait_how_e" ref="ga5e52d786644f3b66d6180571e68c7260" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga5e52d786644f3b66d6180571e68c7260a057885ccf4b8b707e0d115c691037de4"></a><!-- doxytag: member="APR_WAIT" ref="gga5e52d786644f3b66d6180571e68c7260a057885ccf4b8b707e0d115c691037de4" args="" -->APR_WAIT</em>&nbsp;</td><td>
<p>wait for the specified process to finish </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga5e52d786644f3b66d6180571e68c7260a0163031f6b72b0c4add9108052a672d5"></a><!-- doxytag: member="APR_NOWAIT" ref="gga5e52d786644f3b66d6180571e68c7260a0163031f6b72b0c4add9108052a672d5" args="" -->APR_NOWAIT</em>&nbsp;</td><td>
<p>do not wait -- just see if it has finished </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacbe3fd9491fa35149de28cebcae22f87"></a><!-- doxytag: member="apr_thread_proc.h::apr_pool_note_subprocess" ref="gacbe3fd9491fa35149de28cebcae22f87" args="(apr_pool_t *a, apr_proc_t *proc, apr_kill_conditions_e how)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_note_subprocess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga3eaec78633742e7e0cb9480a21477aff">apr_kill_conditions_e</a>&nbsp;</td>
          <td class="paramname"> <em>how</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a process to be killed when a pool dies. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The pool to use to define the processes lifetime </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The process to register </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>how</em>&nbsp;</td><td>How to kill the process, one of: </p>
<pre>
         APR_KILL_NEVER         -- process is never sent any signals
         APR_KILL_ALWAYS        -- process is sent SIGKILL on apr_pool_t cleanup
         APR_KILL_AFTER_TIMEOUT -- SIGTERM, wait 3 seconds, SIGKILL
         APR_JUST_WAIT          -- wait forever for the process to complete
         APR_KILL_ONLY_ONCE     -- send SIGTERM and then wait
 </pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab51dd90b98d365a969f0ec5c7bef4e14"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_create" ref="gab51dd90b98d365a969f0ec5c7bef4e14" args="(apr_proc_t *new_proc, const char *progname, const char *const *args, const char *const *env, apr_procattr_t *attr, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>new_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>progname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new process and execute a new program within that process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_proc</em>&nbsp;</td><td>The resulting process handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progname</em>&nbsp;</td><td>The program to run </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>the arguments to pass to the new program. The first one should be the program name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>env</em>&nbsp;</td><td>The new environment table for the new process. This should be a list of NULL-terminated strings. This argument is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and APR_SHELLCMD_ENV types of commands. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>the procattr we should use to determine how to create the new process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function returns without waiting for the new process to terminate; use apr_proc_wait for that. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56c2b005792752b63d804f2021596406"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_detach" ref="ga56c2b005792752b63d804f2021596406" args="(int daemonize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_detach </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>daemonize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detach the process from the controlling terminal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>daemonize</em>&nbsp;</td><td>set to non-zero if the process should daemonize and become a background process, else it will stay in the foreground. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a5ff2fce2c68460281b0cb3ee0365d5"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_kill" ref="ga4a5ff2fce2c68460281b0cb3ee0365d5" args="(apr_proc_t *proc, int sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_kill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate a process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The process to terminate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sig</em>&nbsp;</td><td>How to kill the process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga88701979c4e5ac4b94966c73e0159efd"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_other_child_alert" ref="ga88701979c4e5ac4b94966c73e0159efd" args="(apr_proc_t *proc, int reason, int status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_other_child_alert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify the maintenance callback of a registered other child process that application has detected an event, such as death. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The process to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>The reason code to pass to the maintenance function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The status to pass to the maintenance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>An example of code using this behavior; <pre>
 rv = apr_proc_wait_all_procs(&amp;proc, &amp;exitcode, &amp;status, APR_WAIT, p);
 if (<a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#ga1e6539dfa172cef4026105ca33b2b208">APR_STATUS_IS_CHILD_DONE(rv)</a>) {
 if APR_HAS_OTHER_CHILD
     if (apr_proc_other_child_alert(&amp;proc, APR_OC_REASON_DEATH, status)
             == APR_SUCCESS) {
         ;  (already handled)
     }
     else
 endif
         [... handling non-otherchild processes death ...]
 </pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74a905d90a3476a611adeeb304931a6c"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_other_child_refresh" ref="ga74a905d90a3476a611adeeb304931a6c" args="(apr_other_child_rec_t *ocr, int reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_proc_other_child_refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#gafc52ee8b19a7b222278d31ebb3f11a71">apr_other_child_rec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ocr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test one specific other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ocr</em>&nbsp;</td><td>The registered other child </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>The reason code (e.g. APR_OC_REASON_RESTART) if still running </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacff5e867a92619d30c4e78f9ad2a58e3"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_other_child_refresh_all" ref="gacff5e867a92619d30c4e78f9ad2a58e3" args="(int reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_proc_other_child_refresh_all </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reason</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test all registered other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>The reason code (e.g. APR_OC_REASON_RESTART) to running processes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8d2be452a819161aa4cd6205a17761e"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_other_child_register" ref="gaf8d2be452a819161aa4cd6205a17761e" args="(apr_proc_t *proc, void(*maintenance)(int reason, void *, int status), void *data, apr_file_t *write_fd, apr_pool_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_proc_other_child_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int reason, void *, int status)&nbsp;</td>
          <td class="paramname"> <em>maintenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>write_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register an other_child -- a child associated to its registered maintence callback. This callback is invoked when the process dies, is disconnected or disappears. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The child process to register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maintenance</em>&nbsp;</td><td>maintenance is a function that is invoked with a reason and the data pointer passed here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Opaque context data passed to the maintenance function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write_fd</em>&nbsp;</td><td>An fd that is probed for writing. If it is ever unwritable then the maintenance is invoked with reason OC_REASON_UNWRITABLE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to use for allocating memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd><p class="startdd">write_fd duplicates the proc-&gt;out stream, it's really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </p>
<p class="enddd">no platform currently tests the pipes health. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga10b1a4b224566c03c97f100ac8a2c830"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_other_child_unregister" ref="ga10b1a4b224566c03c97f100ac8a2c830" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_proc_other_child_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop watching the specified other child. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to pass to the maintenance function. This is used to find the process to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Since this can be called by a maintenance function while we're scanning the other_children list, all scanners should protect themself by loading ocr-&gt;next before calling any maintenance function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0936f7a7fe7e2d5e08979c9f343a5a1b"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_wait" ref="ga0936f7a7fe7e2d5e08979c9f343a5a1b" args="(apr_proc_t *proc, int *exitcode, apr_exit_why_e *exitwhy, apr_wait_how_e waithow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a> *&nbsp;</td>
          <td class="paramname"> <em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a>&nbsp;</td>
          <td class="paramname"> <em>waithow</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for a child process to die </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The process handle that corresponds to the desired child process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exitcode</em>&nbsp;</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exitwhy</em>&nbsp;</td><td>Why the child died, the bitwise or of: </p>
<pre>
            APR_PROC_EXIT         -- process terminated normally
            APR_PROC_SIGNAL       -- process was killed by a signal
            APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                     generated a core dump.
 </pre> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waithow</em>&nbsp;</td><td>How should we wait. One of: </p>
<pre>
            APR_WAIT   -- block until the child process dies.
            APR_NOWAIT -- return immediately regardless of if the 
                          child is dead or not.
 </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The childs status is in the return code to this process. It is one of: <pre>
            APR_CHILD_DONE     -- child is no longer running.
            APR_CHILD_NOTDONE  -- child is still running.
 </pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga506183074e8413c3ff597539e4768ea4"></a><!-- doxytag: member="apr_thread_proc.h::apr_proc_wait_all_procs" ref="ga506183074e8413c3ff597539e4768ea4" args="(apr_proc_t *proc, int *exitcode, apr_exit_why_e *exitwhy, apr_wait_how_e waithow, apr_pool_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_proc_wait_all_procs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__proc__t.html">apr_proc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>exitcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#gac097b4fa41e67024711c5983446d0951">apr_exit_why_e</a> *&nbsp;</td>
          <td class="paramname"> <em>exitwhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga5e52d786644f3b66d6180571e68c7260">apr_wait_how_e</a>&nbsp;</td>
          <td class="paramname"> <em>waithow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for any current child process to die and return information about that child. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to NULL on entry, will be filled out with child's information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exitcode</em>&nbsp;</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exitwhy</em>&nbsp;</td><td>Why the child died, the bitwise or of: </p>
<pre>
            APR_PROC_EXIT         -- process terminated normally
            APR_PROC_SIGNAL       -- process was killed by a signal
            APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                     generated a core dump.
 </pre> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waithow</em>&nbsp;</td><td>How should we wait. One of: </p>
<pre>
            APR_WAIT   -- block until the child process dies.
            APR_NOWAIT -- return immediately regardless of if the 
                          child is dead or not.
 </pre> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Pool to allocate child information out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f1dd02408995767efcb9c0d9c775620"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_addrspace_set" ref="ga0f1dd02408995767efcb9c0d9c775620" args="(apr_procattr_t *attr, apr_int32_t addrspace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_addrspace_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>addrspace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the child should start in its own address space or using the current one from its parent </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrspace</em>&nbsp;</td><td>Should the child start in its own address space? Default is no on NetWare and yes on other platforms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6fad364c6c820e37c0915435cfb3921f"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_child_err_set" ref="ga6fad364c6c820e37c0915435cfb3921f" args="(struct apr_procattr_t *attr, apr_file_t *child_err, apr_file_t *parent_err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_child_err_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>child_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent_err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the child_err and parent_err values to existing apr_file_t values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child_err</em>&nbsp;</td><td>apr_file_t value to use as child_err. Must be a valid file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_err</em>&nbsp;</td><td>apr_file_t value to use as parent_err. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> instead for simple pipes. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa39deba0837e0772754ad41589b733cf"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_child_errfn_set" ref="gaa39deba0837e0772754ad41589b733cf" args="(apr_procattr_t *attr, apr_child_errfn_t *errfn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_child_errfn_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga8f8642f468f05b0ac2b1426b723af100">apr_child_errfn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>errfn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify an error function to be called in the child process if APR encounters an error in the child prior to running the specified program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errfn</em>&nbsp;</td><td>The function to call in the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>At the present time, it will only be called from <a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create()</a> on platforms where fork() is used. It will never be called on other platforms, on those platforms <a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create()</a> will return the error in the parent process rather than invoke the callback in the now-forked child process. </dd></dl>

</div>
</div>
<a class="anchor" id="ga24f40119b1aa07dd45a681a44915cb1b"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_child_in_set" ref="ga24f40119b1aa07dd45a681a44915cb1b" args="(struct apr_procattr_t *attr, apr_file_t *child_in, apr_file_t *parent_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_child_in_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>child_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the child_in and/or parent_in values to existing apr_file_t values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child_in</em>&nbsp;</td><td>apr_file_t value to use as child_in. Must be a valid file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_in</em>&nbsp;</td><td>apr_file_t value to use as parent_in. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. You can save some extra function calls by not creating your own pipe since this creates one in the process space for you. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> instead for simple pipes. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb97e9a49021ab4452ae3f1a281c977f"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_child_out_set" ref="gabb97e9a49021ab4452ae3f1a281c977f" args="(struct apr_procattr_t *attr, apr_file_t *child_out, apr_file_t *parent_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_child_out_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>child_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__file__io.html#gaa46e4763ac375ea3c7a43ba6f6099e22">apr_file_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the child_out and parent_out values to existing apr_file_t values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child_out</em>&nbsp;</td><td>apr_file_t value to use as child_out. Must be a valid file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent_out</em>&nbsp;</td><td>apr_file_t value to use as parent_out. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__thread__proc.html#ga2b1598bc6f5ab0bfcf2e55096d563c98">apr_procattr_io_set</a> instead for simple pipes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1426acc5bdd96385769e7b42bfa6ebbd"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_cmdtype_set" ref="ga1426acc5bdd96385769e7b42bfa6ebbd" args="(apr_procattr_t *attr, apr_cmdtype_e cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_cmdtype_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#gadcb981d7748c580eb69ac11dbf709060">apr_cmdtype_e</a>&nbsp;</td>
          <td class="paramname"> <em>cmd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set what type of command the child process will call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>The type of command. One of: </p>
<pre>
            APR_SHELLCMD     --  Anything that the shell can handle
            APR_PROGRAM      --  Executable program   (default) 
            APR_PROGRAM_ENV  --  Executable program, copy environment
            APR_PROGRAM_PATH --  Executable program on PATH, copy env
 </pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90f8ef684e601c110daad9b63da53cf3"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_create" ref="ga90f8ef684e601c110daad9b63da53cf3" args="(apr_procattr_t **new_attr, apr_pool_t *cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> **&nbsp;</td>
          <td class="paramname"> <em>new_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and initialize a new procattr variable </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_attr</em>&nbsp;</td><td>The newly created procattr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cont</em>&nbsp;</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ccca55041f648f00f0605673d4e0fdc"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_detach_set" ref="ga3ccca55041f648f00f0605673d4e0fdc" args="(apr_procattr_t *attr, apr_int32_t detach)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_detach_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>detach</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the child should start in detached state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detach</em>&nbsp;</td><td>Should the child start in detached state? Default is no. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97766f50b0ae083a2f8a28e698a59baa"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_dir_set" ref="ga97766f50b0ae083a2f8a28e698a59baa" args="(apr_procattr_t *attr, const char *dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_dir_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set which directory the child process should start executing in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dir</em>&nbsp;</td><td>Which dir to start in. By default, this is the same dir as the parent currently resides in, when the createprocess call is made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24076f050e9385af09ad8c3931d8dc43"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_error_check_set" ref="ga24076f050e9385af09ad8c3931d8dc43" args="(apr_procattr_t *attr, apr_int32_t chk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_error_check_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>chk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specify that <a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create()</a> should do whatever it can to report failures to the caller of <a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create()</a>, rather than find out in the child. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chk</em>&nbsp;</td><td>Flag to indicate whether or not extra work should be done to try to report failures to the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This flag only affects <a class="el" href="group__apr__thread__proc.html#gab51dd90b98d365a969f0ec5c7bef4e14">apr_proc_create()</a> on platforms where fork() is used. This leads to extra overhead in the calling process, but that may help the application handle such errors more gracefully. </dd></dl>

</div>
</div>
<a class="anchor" id="ga391f0d3831a5894ea2118762789a395d"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_group_set" ref="ga391f0d3831a5894ea2118762789a395d" args="(apr_procattr_t *attr, const char *groupname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_group_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>groupname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the group used for running process </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupname</em>&nbsp;</td><td>The group name used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b1598bc6f5ab0bfcf2e55096d563c98"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_io_set" ref="ga2b1598bc6f5ab0bfcf2e55096d563c98" args="(apr_procattr_t *attr, apr_int32_t in, apr_int32_t out, apr_int32_t err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_io_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if any of stdin, stdout, or stderr should be linked to pipes when starting a child process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>Should stdin be a pipe back to the parent? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Should stdout be a pipe back to the parent? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Should stderr be a pipe back to the parent? </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If APR_NO_PIPE, there will be no special channel, the child inherits the parent's corresponding stdio stream. If APR_NO_FILE is specified, that corresponding stream is closed in the child (and will be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly side effects, as the next file opened in the child on Unix will fall into the stdio stream fd slot! </dd></dl>

</div>
</div>
<a class="anchor" id="ga741ed3dc047b935b091a21528c49bb19"></a><!-- doxytag: member="apr_thread_proc.h::apr_procattr_user_set" ref="ga741ed3dc047b935b091a21528c49bb19" args="(apr_procattr_t *attr, const char *username, const char *password)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_procattr_user_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga0d83919a6a0dd609598a864917f8b339">apr_procattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>password</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the username used for running process </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The procattr we care about. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>The username used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>User password if needed. Password is needed on WIN32 or any other platform having APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeba6593f43f1de94c2b4495dd72b0e9f"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_create" ref="gaeba6593f43f1de94c2b4495dd72b0e9f" args="(apr_thread_t **new_thread, apr_threadattr_t *attr, apr_thread_start_t func, void *data, apr_pool_t *cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> **&nbsp;</td>
          <td class="paramname"> <em>new_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga37193850d158ca870fc8f8759f0725a9">apr_thread_start_t</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new thread of execution </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_thread</em>&nbsp;</td><td>The newly created thread handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The threadattr to use to determine how to create the thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The function to start the new thread in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Any data to be passed to the starting function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cont</em>&nbsp;</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad799c8140ed068a12f1dbe134423eae7"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_data_get" ref="gad799c8140ed068a12f1dbe134423eae7" args="(void **data, const char *key, apr_thread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_data_get </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pool associated with the current thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data associated with the thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to associate with the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The currently open thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa90d79c9935692db4f27a6573f437221"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_data_set" ref="gaa90d79c9935692db4f27a6573f437221" args="(void *data, const char *key, apr_status_t(*cleanup)(void *), apr_thread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_data_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pool associated with the current thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data to associate with the thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use for associating the data with the thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanup</em>&nbsp;</td><td>The cleanup routine to use when the thread is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The currently open thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadbd186912d5f6f2a19a175e1e02ba10e"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_detach" ref="gadbd186912d5f6f2a19a175e1e02ba10e" args="(apr_thread_t *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>detach a thread </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thd</em>&nbsp;</td><td>The thread to detach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e35365e530578bca1b4bea522ac8c85"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_exit" ref="ga0e35365e530578bca1b4bea522ac8c85" args="(apr_thread_t *thd, apr_status_t retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td>
          <td class="paramname"> <em>retval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>stop the current thread </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thd</em>&nbsp;</td><td>The thread to stop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>retval</em>&nbsp;</td><td>The return value to pass back to any thread that cares </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b950f36fa5bcd5a64887073f46f6d13"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_join" ref="ga1b950f36fa5bcd5a64887073f46f6d13" args="(apr_status_t *retval, apr_thread_t *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> *&nbsp;</td>
          <td class="paramname"> <em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>block until the desired thread stops executing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>retval</em>&nbsp;</td><td>The return value from the dead thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thd</em>&nbsp;</td><td>The thread to join </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f3645ee52ff07566c92181b4ce732d8"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_once" ref="ga8f3645ee52ff07566c92181b4ce732d8" args="(apr_thread_once_t *control, void(*func)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a> *&nbsp;</td>
          <td class="paramname"> <em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run the specified function one time, regardless of how many threads call it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>control</em>&nbsp;</td><td>The control variable. The same variable should be passed in each time the function is tried to be called. This is how the underlying functions determine if the function has ever been called before. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63f3bf667151053e45d5a2029daeda0d"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_once_init" ref="ga63f3bf667151053e45d5a2029daeda0d" args="(apr_thread_once_t **control, apr_pool_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_thread_once_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga91841bcf20d0579e8e6acc6d3c220ac1">apr_thread_once_t</a> **&nbsp;</td>
          <td class="paramname"> <em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the control variable for apr_thread_once. If this isn't called, apr_initialize won't work. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>control</em>&nbsp;</td><td>The control variable to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga089b70ae9d6c64d2675a1fd1e9cd0d0d"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_pool_get" ref="ga089b70ae9d6c64d2675a1fd1e9cd0d0d" args="(const apr_thread_t *thethread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a>* apr_thread_pool_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__apr__thread__proc.html#ga646c71351e723d84f8cc8c8d1d5937be">apr_thread_t</a> *&nbsp;</td>
          <td class="paramname"> <em>thethread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the child-pool used by the thread from the thread info. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>apr_pool_t the pool </dd></dl>

</div>
</div>
<a class="anchor" id="gacd69fb862c069cb6f297f65d64b5c102"></a><!-- doxytag: member="apr_thread_proc.h::apr_thread_yield" ref="gacd69fb862c069cb6f297f65d64b5c102" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>force the current thread to yield the processor </p>

</div>
</div>
<a class="anchor" id="ga66c2f55e5dff9ac37bd32e9febd38da5"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_create" ref="ga66c2f55e5dff9ac37bd32e9febd38da5" args="(apr_threadattr_t **new_attr, apr_pool_t *cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadattr_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> **&nbsp;</td>
          <td class="paramname"> <em>new_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and initialize a new threadattr variable </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_attr</em>&nbsp;</td><td>The newly created threadattr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cont</em>&nbsp;</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5b7cdb3de542d1b7b52fe5d9d8cb00b"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_detach_get" ref="gae5b7cdb3de542d1b7b52fe5d9d8cb00b" args="(apr_threadattr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadattr_detach_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the detach state for this threadattr. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The threadattr to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>APR_DETACH if threads are to be detached, or APR_NOTDETACH if threads are to be joinable. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85d44b3b021f28116122d5e40e024648"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_detach_set" ref="ga85d44b3b021f28116122d5e40e024648" args="(apr_threadattr_t *attr, apr_int32_t on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadattr_detach_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int32_t&nbsp;</td>
          <td class="paramname"> <em>on</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set if newly created threads should be created in detached state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The threadattr to affect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on</em>&nbsp;</td><td>Non-zero if detached threads should be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e732f2913291180c0c484f57d727140"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_guardsize_set" ref="ga2e732f2913291180c0c484f57d727140" args="(apr_threadattr_t *attr, apr_size_t guardsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadattr_guardsize_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>guardsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the stack guard area size of newly created threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The threadattr to affect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>guardsize</em>&nbsp;</td><td>The stack guard area size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Thread library implementations commonly use a "guard area" after each thread's stack which is not readable or writable such that stack overflows cause a segfault; this consumes e.g. 4K of memory and increases memory management overhead. Setting the guard area size to zero hence trades off reliable behaviour on stack overflow for performance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7849e0d637338a18cb44f66f11f28ed1"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadattr_stacksize_set" ref="ga7849e0d637338a18cb44f66f11f28ed1" args="(apr_threadattr_t *attr, apr_size_t stacksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadattr_stacksize_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga35de571e9944871c10b38d8feef885ac">apr_threadattr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>stacksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the stack size of newly created threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>The threadattr to affect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stacksize</em>&nbsp;</td><td>The stack size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae203664972dfc5c555620ae1788f5b48"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_data_get" ref="gae203664972dfc5c555620ae1788f5b48" args="(void **data, const char *key, apr_threadkey_t *threadkey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_data_get </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>threadkey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pool associated with the current threadkey. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data associated with the threadkey. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key associated with the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadkey</em>&nbsp;</td><td>The currently open threadkey. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1059158f34dded87f21ba82af1211951"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_data_set" ref="ga1059158f34dded87f21ba82af1211951" args="(void *data, const char *key, apr_status_t(*cleanup)(void *), apr_threadkey_t *threadkey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_data_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>threadkey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pool associated with the current threadkey. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to associate with the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanup</em>&nbsp;</td><td>The cleanup routine to use when the file is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadkey</em>&nbsp;</td><td>The currently open threadkey. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacb9553b2b3165388bfc0a54b1148804a"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_private_create" ref="gacb9553b2b3165388bfc0a54b1148804a" args="(apr_threadkey_t **key, void(*dest)(void *), apr_pool_t *cont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_private_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> **&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cont</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create and initialize a new thread private address space </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The thread private handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destructor to use when freeing the private memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cont</em>&nbsp;</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20b9b79892a6532784fff023a4ebd8cf"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_private_delete" ref="ga20b9b79892a6532784fff023a4ebd8cf" args="(apr_threadkey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_private_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free the thread private memory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The handle for the desired thread private memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga371c87c122cc3df0b7ad0031f6e11167"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_private_get" ref="ga371c87c122cc3df0b7ad0031f6e11167" args="(void **new_mem, apr_threadkey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_private_get </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>new_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a pointer to the thread private memory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_mem</em>&nbsp;</td><td>The data stored in private memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The handle for the desired thread private memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63501a064ca7f1818aa056b40146aa0b"></a><!-- doxytag: member="apr_thread_proc.h::apr_threadkey_private_set" ref="ga63501a064ca7f1818aa056b40146aa0b" args="(void *priv, apr_threadkey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_threadkey_private_set </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__thread__proc.html#ga337c9c1bd2d47740022071a5c41f2edb">apr_threadkey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the data to be stored in thread private memory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>priv</em>&nbsp;</td><td>The data to be stored in private memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The handle for the desired thread private memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
